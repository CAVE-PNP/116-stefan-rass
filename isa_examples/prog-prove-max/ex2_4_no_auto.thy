theory ex2_4_no_auto
  imports Main
begin

fun snoc :: "'a list \<Rightarrow> 'a \<Rightarrow> 'a list" where
  snoc_init: "snoc [] a = a # []" |
  snoc_step: "snoc (x # lst) a = x # (snoc lst a)"

fun reverse :: "'a list \<Rightarrow> 'a list" where
  rev_init: "reverse [] = []" |
  rev_step: "reverse (a # lst) = snoc (reverse lst) a"


lemma rev_snoc [simp]: 
  fixes lst a
  shows "reverse (snoc lst a) = a # (reverse lst)"
proof (induction lst)
(*
 * the induction case template contains "case (Cons a lst)"
 * which overwrites the fixed "a" from the signature (which serves a different purpose).
 * this is an issue, as the exported Cons.IH rule cannot be used correctly.
 *
 * the induction tactic seems to choose the label "a" regardless of the lemma signature
 * and any definitions in this theory.
 * 
 * this can be easily avoided by renaming "a" in the signature, or in the "case" statement,
 * but is unintuitive and can lead to confusion.
 *
 * todo see if the different name of "case (Cons *a* lst)" to the one generated by induction makes a difference
 *)
  case Nil
  have "reverse (snoc [] a) = reverse [a]" 
    unfolding snoc_init by (rule refl)
  also have "reverse [a] = [a]" unfolding reverse.simps snoc_init by (rule refl)
  also have "[a] = a # reverse []" unfolding rev_init by (rule refl)
  finally show ?case .
next
  case (Cons aa lst)
  have "reverse (snoc (aa # lst) a) = reverse (aa # snoc lst a)"
    unfolding snoc_step by (rule refl)
  also have "reverse (aa # snoc lst a) = snoc (reverse (snoc lst a)) aa"
    unfolding rev_step by (rule refl)
  thm Cons.IH
  also have "snoc (reverse (snoc lst a)) aa = snoc (a # reverse lst) aa"
    by (subst Cons.IH) (rule refl)
  also have "snoc (a # reverse lst) aa = a # snoc (reverse lst) aa"
    unfolding snoc_step by (rule refl)
  also have "a # snoc (reverse lst) aa = a # reverse (aa # lst)"
    unfolding rev_step by (rule refl)
  finally show ?case .
qed

(*
 * the next proof is somewhat shorter due to the lack of intermediate steps.
 * while this style of proof does not work in all situations, it does on the previous lemma.
 * this may explain why "auto" is able to solve at least these problems.
 *)

lemma 
  fixes lst
  shows "reverse (reverse lst) = lst"
proof (induction lst)
  case Nil
  show ?case
    unfolding rev_init
    by (rule refl)
next
  case (Cons a lst)
  show ?case
    unfolding rev_step rev_snoc Cons.IH
      (* just unfolding everything already yields an identity equation *)
    by (rule refl)
qed

end